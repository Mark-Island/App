name: "App F-A/I-R"

on:
  push:
    branches: [ main ]
    tags: "[0-9]+.[0-9]+.[0-9]+"
  pull_request_target:
    branches: [ main ]
    types: [opened, synchronize, reopened]


jobs:
  fork_apply:
    name: "Fork Apply"
    if: github.event_name == 'push' && github.repository != 'appfair/App'

    runs-on: macos-11
    timeout-minutes: 20

    env:
      DEVELOPER_DIR: /Applications/Xcode_13.0.app/Contents/Developer

    steps:
      - name: "Initialize fair-ground"
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: |
          echo "$GITHUB_CONTEXT"
          echo "$GITHUB_CONTEXT"
          echo "ORGNAME=${{ github.repository_owner }}" >> $GITHUB_ENV
          echo "COMMITHASH=${{ github.sha }}" >> $GITHUB_ENV

      - name: "Configure Fork: ${{ env.ORGNAME }}"
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: |
          echo "FAIR_APP_ARTIFACT=${{ env.ORGNAME }}" >> $GITHUB_ENV
          echo "PRODUCT_NAME=$(echo ${{ env.ORGNAME }} | tr '-' ' ')" >> $GITHUB_ENV
          echo "BUNDLE_ID=app.$(echo ${{ env.ORGNAME }})" >> $GITHUB_ENV
          echo "BUILDING PRODUCT: ${{ env.PRODUCT_NAME }}"
      
      - name: Checkout
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - name: "Validate App Org: ${{ env.ORGNAME }}"
        run: xcrun swift run -- fairtool validate --verbose true --hub github.com/appfair --org "${{ env.ORGNAME }}" --token "${{ secrets.GITHUB_TOKEN }}" --project . --output -

      - name: "Generate Icon"
        run: xcrun swift run -- fairtool icon --org "${{ env.ORGNAME }}" --output Assets.xcassets/AppIcon.appiconset/AppIcon-1024.png --output Assets.xcassets/AppIcon.appiconset/AppIcon-512.png || true # tolerate failure

      - name: Test Swift Package
        if: github.event_name == 'push' # only run tests in forks
        run: xcrun swift test

      - name: "Build macOS App"
        run: |
          xcodebuild archive \
            -workspace "App.xcworkspace" \
            -configuration Release \
            -scheme "AppFairApp" \
            -sdk "macosx" \
            -destination 'platform=macOS' \
            -archivePath "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.xcarchive" \
            CODE_SIGNING_REQUIRED=YES \
            CODE_SIGNING_ALLOWED=YES \
            AD_HOC_CODE_SIGNING_ALLOWED=YES \
            CODE_SIGN_IDENTITY="-" \
            PRODUCT_BUNDLE_IDENTIFIER="${{ env.BUNDLE_ID }}" \
            FAIRAPP_PRODUCT_NAME="${{ env.PRODUCT_NAME }}"

          echo '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"><plist version="1.0"><dict><key>method</key><string>mac-application</string><key>signingStyle</key><string>automatic</string><key>uploadBitcode</key><false/><key>compileBitcode</key><false/><key>uploadSymbols</key><false/></dict></plist>' > "staging/exportOptions.plist"

          xcodebuild \
            -exportArchive \
            -archivePath "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.xcarchive" \
            -exportPath "staging/" \
            -exportOptionsPlist "staging/exportOptions.plist"

          codesign --verify --verbose=5 "staging/${{ env.PRODUCT_NAME }}.app"
          codesign -dv --verbose=5 "staging/${{ env.PRODUCT_NAME }}.app"
          codesign -d --entitlements - "staging/${{ env.PRODUCT_NAME }}.app"

          # create the zip file
          ditto -c -k --sequesterRsrc --keepParent "staging/${{ env.PRODUCT_NAME }}.app" "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.zip"

          # show the binary checksum
          ls -la "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.zip"
          ls -la "staging/${{ env.PRODUCT_NAME }}.app/Contents/MacOS/"*
          openssl sha256 "staging/${{ env.PRODUCT_NAME }}.app/Contents/MacOS/"*
          openssl sha256 "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.zip"

      # Notarization is not required for the App Fair, but a developer
      # can opt to notarize their own build which will allow them to 
      # distribute the app outside of the App Fair without having to
      # make a separate notarized release.
      #
      # The App Fair's app validation does not take into account the
      # notarization or signing status of the zip when it validates
      # the release artifacts, nor does it have access to the signing
      # secrets for the fork's repository, and so the app can be signed
      # with any certificate the developer likes. 
      #
      # Custom signing would need to happen
      # before the exporting of the binary (above), and is left
      # as an exercise for the enterprising developer (who may use a
      # tool like devbotsxyz/xcode-import-certificate for importing the
      # certificate).
      - name: "Notarize macOS App"
        if: false # "${{ secrets.FAIR_NOTARIZATION_TEAMID }} != ''"
        run: xcrun notarytool submit "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.zip" --password "${{ secrets.FAIR_NOTARIZATION_PASSWORD }}" --apple-id "${{ secrets.FAIR_NOTARIZATION_USERNAME }}" --team-id "${{ secrets.FAIR_NOTARIZATION_TEAMID }}" --progress --wait

      - name: "Build iOS App"
        # there's no way to export iOS archives without re-signing with a teamID, 
        # so just build the .ipa manually; it needs to be in staging/ first
        run: |
          xcodebuild archive \
            -workspace "App.xcworkspace" \
            -configuration Release \
            -scheme "AppFairApp" \
            -sdk "iphoneos" \
            -archivePath "staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.xcarchive" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            AD_HOC_CODE_SIGNING_ALLOWED=YES \
            CODE_SIGN_IDENTITY="-" \
            PRODUCT_BUNDLE_IDENTIFIER="${{ env.BUNDLE_ID }}" \
            FAIRAPP_PRODUCT_NAME="${{ env.PRODUCT_NAME }}"
          cp -a "staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.xcarchive/Products/Applications" "staging/Payload"
          ditto -c -k --sequesterRsrc --keepParent "staging/Payload" "staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.ipa"
          rm -rf "staging/Payload" # cleanup
          ls -la "staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.ipa"

      # Notarization is not yet supported for iOS apps.
      - name: "Notarize iOS App"
        if: false # "${{ secrets.FAIR_NOTARIZATION_TEAMID }} != ''"
        run: xcrun notarytool submit "staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.ipa" --password "${{ secrets.FAIR_NOTARIZATION_PASSWORD }}" --apple-id "${{ secrets.FAIR_NOTARIZATION_USERNAME }}" --team-id "${{ secrets.FAIR_NOTARIZATION_TEAMID }}" --progress --wait

      - name: "Stage Release Metadata"
        # Extract the Info.plist from the archives themselves, since they contain
        # the same post-processed metadata that the app will use.
        # And convert to XML for ease of integration.
        run: |
          cp Assets.xcassets/AppIcon.appiconset/AppIcon-1024.png staging/"${{ env.FAIR_APP_ARTIFACT }}.png"
          plutil -convert xml1 -r -o "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.plist" -- "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.xcarchive/Products/Applications/${{ env.PRODUCT_NAME }}.app/Contents/Info.plist"
          plutil -convert xml1 -r -o "staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.plist" -- "staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.xcarchive/Products/Applications/${{ env.PRODUCT_NAME }}.app/Info.plist"
          find "staging/" -type f

      # create and upload the release artifacts, which will be
      # vaidates in the base fair-ground by integrate_release
      - name: "Release App"
        if: startsWith(github.ref, 'refs/tags/') && github.event_name == 'push'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Creating release: ${GITHUB_REF#refs/tags/}"
          gh release create \
            "${GITHUB_REF#refs/tags/}" \
            -- \
            Sandbox.entitlements \
            Package.resolved \
            staging/${{ env.FAIR_APP_ARTIFACT }}.png \
            staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.zip \
            staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.plist \
            staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.ipa \
            staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.plist


  integrate_release:
    name: "Integrate Release"
    if: github.event_name == 'pull_request_target' && github.repository == 'appfair/App'

    runs-on: macos-11
    timeout-minutes: 15
    env:
      DEVELOPER_DIR: /Applications/Xcode_13.0.app/Contents/Developer

    steps:
      - name: "Initialize fair-ground"
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: |
          echo "$GITHUB_CONTEXT"
          echo "PRTITLE=${{ github.event.pull_request.title }}" >> $GITHUB_ENV
          echo "ORGNAME=${{ github.event.pull_request.head.user.login }}" >> $GITHUB_ENV
          echo "COMMITHASH=${{ github.event.pull_request.head.sha }}" >> $GITHUB_ENV
          echo "PRID=${{ github.event.pull_request.id }}" >> $GITHUB_ENV

      - name: "Configure App: ${{ env.ORGNAME }}"
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: |
          echo "FAIR_APP_ARTIFACT=${{ env.ORGNAME }}" >> $GITHUB_ENV
          echo "PRODUCT_NAME=$(echo ${{ env.ORGNAME }} | tr '-' ' ')" >> $GITHUB_ENV
          echo "BUNDLE_ID=app.$(echo ${{ env.ORGNAME }})" >> $GITHUB_ENV
          echo "BUILDING PRODUCT: ${{ env.PRODUCT_NAME }}"
      
      - name: Checkout Base Fairground
        uses: actions/checkout@v2

      - name: Checkout Integrate PR
        uses: actions/checkout@v2
        with:
          path: ReleasePR
          ref: ${{ env.COMMITHASH }}
          fetch-depth: 0
          submodules: false

      - name: Get PR commit message
        id: get_commit_message
        run: echo ::set-output name=commit_message::$(git -C ReleasePR log --format=%B -n 1 "${{ env.COMMITHASH }}")

      - name: Get PR commit tag
        id: get_commit_tag
        if: false # doesn't work for some reason
        run: echo ::set-output name=commit_message::$(git -C ReleasePR tag "${{ env.COMMITHASH }}") # doesn't work for some reason

      - name: Get app version
        id: get_app_version
        run: echo ::set-output name=app_version::$(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' ReleasePR/Info.plist)

      - name: "Validate App-Org: ${{ env.ORGNAME }}"
        run: xcrun swift run -- fairtool validate --verbose true --hub github.com/appfair --org "${{ env.ORGNAME }}" --ref "${{ env.COMMITHASH }}" --integrationTitle "${{ env.PRTITLE }}" --maxsize $[1 * 1024 * 1024] --allow-from '.*.EDU' --allow-from '.*.appfair.net' --allow-from '.*@.*' --token "${{ secrets.GITHUB_TOKEN }}" --project ReleasePR --output -

      - name: Integrate PR
        if: startsWith(steps.get_commit_message.outputs.commit_message, 'release')

        run: |
          rm -rf "staging/"
          mkdir "staging/"

          xcrun swift run -- fairtool merge --verbose true --hub github.com/appfair --org "${{ env.ORGNAME }}" --token "${{ secrets.GITHUB_TOKEN }}" --version-marker-dir "staging/" --project ReleasePR --output .

          xcrun swift package resolve
          xcrun swift run -- fairtool validate --hub github.com/appfair --org "${{ env.ORGNAME }}" --token "${{ secrets.GITHUB_TOKEN }}" --project .

          # next generate a default icon, if one doesn't yet exist
          xcrun swift run -- fairtool icon --org "${{ env.ORGNAME }}" --output Assets.xcassets/AppIcon.appiconset/AppIcon-1024.png --output Assets.xcassets/AppIcon.appiconset/AppIcon-512.png || true # tolerate failure
          file Assets.xcassets/AppIcon.appiconset/AppIcon-1024.png
        
          #xcrun swift run -- fairtool edit --project . --hub github.com/appfair --bundle-id "${{ env.BUNDLE_ID }}" --display-name "${{ env.PRODUCT_NAME }}"

          cp -a .build/checkouts Dependencies
          tar cvzf "staging/${{ env.FAIR_APP_ARTIFACT }}-source.tgz" --exclude='.git/' --exclude='.build/' --exclude='staging/' .
          rm -rf Dependencies

      - name: "Build macOS App: ${{ env.FAIR_APP_ARTIFACT }}-macOS.zip"
        run: |
          xcodebuild archive \
            -workspace "App.xcworkspace" \
            -configuration Release \
            -scheme "AppFairApp" \
            -sdk "macosx" \
            -destination "platform=macOS" \
            -archivePath "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.xcarchive" \
            CODE_SIGNING_REQUIRED=YES \
            CODE_SIGNING_ALLOWED=YES \
            AD_HOC_CODE_SIGNING_ALLOWED=YES \
            CODE_SIGN_IDENTITY="-" \
            PRODUCT_BUNDLE_IDENTIFIER="${{ env.BUNDLE_ID }}" \
            FAIRAPP_PRODUCT_NAME="${{ env.PRODUCT_NAME }}"

          echo '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"><plist version="1.0"><dict><key>method</key><string>mac-application</string><key>signingStyle</key><string>automatic</string></dict></plist>' > "staging/exportOptions.plist"

          xcodebuild \
            -exportArchive \
            -archivePath "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.xcarchive" \
            -exportPath "staging/" \
            -exportOptionsPlist "staging/exportOptions.plist"

          codesign --verify --verbose=5 "staging/${{ env.PRODUCT_NAME }}.app"
          codesign -dv --verbose=5 "staging/${{ env.PRODUCT_NAME }}.app"
          codesign -d --entitlements - "staging/${{ env.PRODUCT_NAME }}.app"
          ditto -c -k --sequesterRsrc --keepParent "staging/${{ env.PRODUCT_NAME }}.app" "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.zip"

          # show the binary checksum
          ls -la "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.zip"
          ls -la "staging/${{ env.PRODUCT_NAME }}.app/Contents/MacOS/"*
          openssl sha256 "staging/${{ env.PRODUCT_NAME }}.app/Contents/MacOS/"*
          openssl sha256 "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.zip"

      - name: "Build iOS App: ${{ env.FAIR_APP_ARTIFACT }}-iOS.ipa"
        # there's no way to export iOS archives without re-signing with a teamID, 
        # so just build the .ipa manually; it needs to be in Staging/ first
        run: |
          xcodebuild archive \
            -workspace "App.xcworkspace" \
            -configuration Release \
            -scheme "AppFairApp" \
            -sdk "iphoneos" \
            -archivePath "staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.xcarchive" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            AD_HOC_CODE_SIGNING_ALLOWED=YES \
            CODE_SIGN_IDENTITY="-" \
            PRODUCT_BUNDLE_IDENTIFIER="${{ env.BUNDLE_ID }}" \
            FAIRAPP_PRODUCT_NAME="${{ env.PRODUCT_NAME }}"
          cp -a "staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.xcarchive/Products/Applications" "staging/Payload"
          ditto -c -k --sequesterRsrc --keepParent "staging/Payload" "staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.ipa"
          rm -rf "staging/Payload" # cleanup
          ls -la "staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.ipa"


      - name: Stage Release Metadata
        # Extract the Info.plist from the archives themselves, since they contain
        # the same post-processed metadata that the app will use.
        # And convert to XML for ease of integration.
        run: |
          cp Assets.xcassets/AppIcon.appiconset/AppIcon-1024.png staging/"${{ env.FAIR_APP_ARTIFACT }}.png"
          plutil -convert xml1 -r -o "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.plist" -- "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.xcarchive/Products/Applications/${{ env.PRODUCT_NAME }}.app/Contents/Info.plist"
          plutil -convert xml1 -r -o "staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.plist" -- "staging/${{ env.FAIR_APP_ARTIFACT }}-iOS.xcarchive/Products/Applications/${{ env.PRODUCT_NAME }}.app/Info.plist"
          find "staging/" -type f


      - name: "Upload Build Artifacts"
        # there can only be a single release artifact at a single time, so we 
        # additionally upload the artifacts for each build for the historical record
        uses: actions/upload-artifact@v2
        with:
          path: staging


      - name: "Download ReleaseArtifacts"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release download --repo=${{ env.ORGNAME }}/App --dir UNTRUSTED -- "${{ steps.get_app_version.outputs.app_version }}" \
                                                                                            || (sleep 60 && gh release download --repo=${{ env.ORGNAME }}/App --dir UNTRUSTED -- "${{ steps.get_app_version.outputs.app_version }}" ) \
                                                                                            || (sleep 60 && gh release download --repo=${{ env.ORGNAME }}/App --dir UNTRUSTED -- "${{ steps.get_app_version.outputs.app_version }}" ) \
                                                                                            || (sleep 60 && gh release download --repo=${{ env.ORGNAME }}/App --dir UNTRUSTED -- "${{ steps.get_app_version.outputs.app_version }}" ) 


      # compare the contents of the PR's un-trusted artifacts with
      # the contents of the base fair-ground's trusted artifacts
      - name: "Compare Trusted & Un-Trusted Artifacts"
        run: |
          mkdir fairseal/
          ls -la UNTRUSTED/

          mkdir fairseal/extracts/
          ditto -xk "staging/${{ env.FAIR_APP_ARTIFACT }}-macOS.zip" fairseal/extracts/trusted/
          ditto -xk "UNTRUSTED/${{ env.FAIR_APP_ARTIFACT }}-macOS.zip" fairseal/extracts/UNTRUSTED/

          # check that contents are identical, first excising
          # signatures to permit custom signing & notarization
          # find fairseal/extracts/trusted fairseal/extracts/UNTRUSTED -name _CodeSignature -type d -exec rm -r "{}" \;
          diff -r fairseal/extracts/trusted fairseal/extracts/UNTRUSTED

          ZIPSHA=$(shasum -a 256 "UNTRUSTED/${{ env.FAIR_APP_ARTIFACT }}-macOS.zip" | cut -f 1 -d ' ')

          # if the seals match, we indicate success by attaching
          # the SHA256 to the end of the release file name; client
          # apps will use this hash to verify that the untrusted release
          # artifact that is downloaded matches the release artifact 
          # that was created in the trusted environment
          echo "${ZIPSHA}" > "fairseal/${{ env.FAIR_APP_ARTIFACT }}-macOS.zip-${{ steps.get_app_version.outputs.app_version }}-${ZIPSHA}.sha256"


      - name: "Publish fairseal"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Creating release: ${{ env.FAIR_APP_ARTIFACT }}"
          gh release create \
            "${{ env.FAIR_APP_ARTIFACT }}" \
            --prerelease --draft \
            -- \
            fairseal/*.*

      - name: "Update App Fair Catalog"
        run: |
          xcrun swift run -- fairtool catalog --verbose true --hub github.com/appfair --token "${{ secrets.GITHUB_TOKEN }}" -o staging/fairapps.json.gz
          gunzip --keep staging/fairapps.json.gz

      - name: "Refresh App Fair Catalog"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Creating release: ${{ env.FAIR_APP_ARTIFACT }}"
          gh release delete --yes "catalog"
          gh release create "catalog" --title "App Fair Catalog" -- staging/fairapps.json staging/fairapps.json.gz
          gh workflow --repo appfair/App run "App Fair Catalog" --field apporg="${{ env.ORGNAME }}"


